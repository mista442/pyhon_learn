# {} dict - словарь
# словарь хранит данные формата - ключ : значение

# типы данных, которые могут принимать ключ и значение
# key может хранить - str,int,double,tuple (только неизменяемы типы данных)
# value может хранить - str,int,double,tuple,list (и те и другие)

# словарь состоит из пар ключ:значение, которые отделяются запятыми.

#если ключи в словаре повторяются, то при обработке данных - берется последнее в словаре значение для повторяющегося ключа ("Виктор": 18)
p_ages = {"Андрей": 32, "Виктор": 29, "Максим": 18, "Виктор": 18}
print(p_ages) # {"Андрей": 32, "Виктор": 18, "Максим": 18}

# ключ -2 дублируется, поэтому при выводе словаря - отобразится ключ -2 со значением 8.
p_ages1 = {1:1, -2:3.2, 19.2:1, -2:8, 'hello':10.1, 'test':'rere'}
print(p_ages1) # {1:1, -2:8, 19.2:1, 'hello':10.1, 'test':'rere'}

p_ages2 = {(1,2):"test", 10:5.1,('hello',10,2.2):8}
print(p_ages2)

# в словарь нельзя добавлять листы в качестве ключа, т.к. это изменяемый тип данных
#p_ages3 = {[1,2,3]:'test'}

# но листы можно использовать в качестве значения
p_ages4 = {(1,2,3):['test',1,2.5]}
print(p_ages4)

# ключи могу содержать вложенные структуры хранения, НО только неизменяемые. Интерпритатор будет ругаться, если попытаться использовать изменяемые типы данных в ключах. Ошибка будет такая - TypeError: unhashable type: 'list'

p_ages = {('Андрей',1,(2,3,4)): 32, "Виктор": 29} # так можно, т.к. (2,3,4) это кортеж.
p_ages = {('Андрей',1,[2,3,4]): 32, "Виктор": 29} # так нельзя, т.к. [2,3,4] это лист.

print(p_ages['Андрей',1,(2,3,4)]) # отобразить значение ключа: 'Андрей',1,(2,3,4). # 32
print(type(p_ages['Андрей',1,(2,3,4)])) # вернет тип значения (int). Имеется ввиду смотрит какой тип у значения 32.


#------------ данные из другой перменной использовать в качестве значения ключа

list1 = [1,2,3]
a = {'test':10, 48:'hello', 1:23}
a = {'test':list1, 48:'hello', 1:23} # данные копируются по ссылке при указании переменной в качестве значения ключа

print(a) # a = {'test': [1, 2, 3], 48: 'hello', 1: 23}

list1[1] = 55 # list1 = [1,55,3]
a = {'test':list1[:], 48:'hello', 1:23} # a = {'test': [1, 55, 3], 48: 'hello', 1: 23}
list1[1] = 70 # list1 = [1,70,3]

# данные в ключ test скопированы по значению, по этому теперь изменения в list1 и в значении ключа test независимы друг от друга
print(a) # a = {'test': [1, 55, 3], 48: 'hello', 1: 23}

print(id(list1))
print(id(a['test'])) # [1, 55, 3]
print(list1) # [1,70,3]
print(a['test']) # [1, 55, 3]

# словари не имеют доступа по индекса как например в типе данных list или tuple.
# вместо этого в словарях можно обращаться получать доступ к элементам по имени ключа словаря. Ключ принимает только неимзенняемые типы данных

print(p_ages["Андрей"]) # отобразить значение ключа "Андрей" - 32
# print(p_ages[32]) # при вводе несуществующщего ключа словаря - программа будет аварийно завершаться. (KeyError: 32)

# p_ages2 = {(1,2):"test", 10:5.1,('hello',10,2.2):8}
print(p_ages2[(1,2)]) # отобразить значение ключа (1,2)
print(p_ages2.get(10)) # тоже самое что и print(p_ages2[10])

a = {'test':[1,2,3], 'test2':(10,11,12), 15: 'test3'}
print(a)
print(type(a))

# словари можно делать вложенными друг в друга и записывать столбцом, а не в строку:

floor1 = {
    'Sw0':{
        'vendor':'cisco',
        'mac':'aa-bb-cc',
        'ip':'192.168.88.10',
        'ios':'15.4'
    },
    'Sw1': {
        'mac': 'bb-cc-dd',
        'ip': '192.168.89.10',
        'ios': '15.4',
        'vendor': 'cisco'
    },
    'Sw2': {
        'mac': 'cc-dd-ee',
        'ip': '192.168.90.10',
        'ios': '15.4',
        'vendor': 'cisco'
    }
}

print(floor1) # выводится на экран будет одной строкой.
print(floor1['Sw0']) # #отобразить значение ключа Sw0
print(floor1['Sw0']['ios']) #отобразить значение ключа вложенного словаря
# в переменной floor1, в для ключа Sw0 отобразить значение вложенного ключа ios - 15.4

print(floor1.get(input("введите название устройства "))) # нужно ввести имя ключа (Sw0 или Sw1 или Sw2) - и выведется его значение.
# Или print(floor1.[(input("введите название устройства "))]) - аналогично будет строчке выше

b = {1:10,1:45,2:18,1:33} # ключи словаря могут повторятся

# но при выводе значения повторяющего ключа - отобразится самый последний элемент для этого ключа во всем словаре.
print(b[1]) # 33

#-------------- методы словарей

#------ метод .keys() - возвращает всю ключи словаря
print(floor1.keys()) # dict_keys(['Sw0', 'Sw1'])

#------ метод .items() - возвращает элементы словаря (ключ,значение) в отформатированном виде
print(floor1.items()) # dict_items([('Sw0', {'vendor': 'cisco', 'mac': 'aa-bb-cc', 'ip': '192.168.88.10', 'ios': '15.4'}), ('Sw1', {'mac': 'bb-cc-dd', 'ip': '192.168.89.10', 'ios': '15.4', 'vendor': 'cisco'})])

#------ метод .get() - возвращает значение по ключу элемента

print(floor1.get('Sw0')) # {'vendor': 'cisco', 'mac': 'aa-bb-cc', 'ip': '192.168.88.10', 'ios': '15.4'}
print(floor1['Sw0']) # тоже самое что и строчка выше

#------ метод .clear() - удалить в словаре все элементы - сделать словарь пустым.

c = {1:10,1:45,2:18,1:33}
c.clear()
print(c) # {}

#------ метод .copy - возвращает копию словаря (указано чуть ниже)

#------ метод .len() - возвращает количество элементов словаря - пары ключ:значение

print('------------')
c = {'test':10,'test':45,'byu':18,'test':33}
print(len(c)) # вернет количество элементов 2, а не 4. Т.к. ключ 'test' - повторяется 3 раза в словаре.
# в сумме получаем 2 ключа - 'test' и 'byu'.

#------ метод .fromkeys() - позволяет создать словарь из списка, элементы которого станут ключами.

list2 = [1,2,3]
d2 = dict.fromkeys(list2) # создаем ключи на основе элементов листа. Ключи будут содержать пустые значения
print(d2) # {1: None, 2: None, 3: None}

d2 = dict.fromkeys(list2,15) # в словарь с пустыми ключами 1,2,3 - ложим значение 15 в каждый ключ.
print(d2) # {1: 15, 2: 15, 3: 15}

#----------------------------- добавление в словарь новых ключей

employees = {'Sergey': 32, 'Anton': 48, 'Vasiliy': 23}
employees["Olga"]=32 # добавится последним элементов в словаре ключ Olga со значением 32
print(employees) # {'Sergey': 32, 'Anton': 48, 'Vasiliy': 23, 'Olga': 32}

#---------- удаление из словаря ключей

del employees["Olga"] # удалить ключ Olga из словаря employees
print(employees) # {'Sergey': 32, 'Anton': 48, 'Vasiliy': 23}

#---------- присвание по ссылке и копирование по значению

#аналогично как в списках - при присваивании через переменную - копирование делается по ссылке.

new=employees
del employees['Anton']

print(employees) # {'Sergey': 32, 'Vasiliy': 23}
print(new) # {'Sergey': 32, 'Vasiliy': 23}

# id у них тоже будет одинаковый

# А через метод copy копируем по значению.
new=employees.copy()
employees['Anton']=18

print(employees) # {'Sergey': 32, 'Vasiliy': 23, 'Anton': 18}
print(new) # {'Sergey': 32, 'Vasiliy': 23}

#-----------------способы создания словаря
d1 = dict()
print(type(d1)) # <class 'dict'>

d2 = {}
print(type(d2)) # <class 'dict'>

d1 = dict(Vasya='tester',Boris='designer')
print(d1)

d2 = {"Alexey":"manager","Olga":"tester"}
print(d2)

#------ метод .setdefault() - добавить новый элемент с ключом и значением в словарь

d2.setdefault('Sergey','Cdder') # аналогично команде - d2["Sergey1"]='Coder'
print(d2) #{'Alexey': 'manager', 'Olga': 'tester', 'Sergey': 'Cdder'}

#------ метод .update - обьединить два словаря в один. Работает как конкатенация (сложение) строк.
# в качестве аргумента можно указать словарь, или переменную содержащую словарь

d2.update({1:10,20:12})
print(d2) # {'Alexey': 'manager', 'Olga': 'tester', 'Sergey': 'Cdder', 1: 10, 20: 12}

d3={'Olga':'worker','John':'Admin',1:9,21:45}

d2.update(d3) # если ключи пересекаются при обьединении, то берется значение из последнего ключа (из того, который присоедияем)
print(d2) # {'Alexey': 'manager', 'Olga': 'worker', 'Sergey': 'Cdder', 1: 9, 20: 12, 'John': 'Admin', 21: 45}

# в зависимости от того какая структура хранения используется в качестве значения - тот подход к ее изменению и надо применять.
# например, для ключа Sergey - изменить 2 элемент списка.
d4 = {"Maxim":[15,42],"Sergey":['test',15,-2.1]}
d4["Sergey"][2]=45
print(d4) # {'Maxim': [15, 42], 'Sergey': ['test', 15, 45]}



