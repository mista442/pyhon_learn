# set {} - множества
# в отличии от словаря где в качестве элемента выступают key:value, в множестве фигурирует только элемент.
# элемент множества может принимать только неизменяемые типы данных - int,float,str,tuple
# и во вложенные структуры данных изменяемые типы данных добавлять тоже нельзя

# обычно множества используют для обьдинения общей информации из разных множеств, или нахождения только уникальных элементов между разными множествами

# 1. если в множестве заданы повторяются элементы, то в выводе отобразятся только уникальные элементы.
# 2. элементы множества возвращаются всегда в неупорядоченном виде!

a = {'a','b','c','d','b','c','d'}
print(type(a)) # <class 'set'>

print(a) # {'a', 'b', 'd', 'c'} # или могут вернуть в другом виде

b = {1,'test',(1,"hello"),-2.5,'a','b'}
print(b) # {-2.5, 'test', (1, 'hello'), 1}


# a = {'a','b','c','d','b','c','d'}
a.add('e') # добавить новый элемент в множество
print(a) # {'a', 'e', 'c', 'b', 'd'}

a.discard('c') # удалить из множества указанный элемент
print(a) # {'a', 'e', 'd', 'b'}

c=a|b # объединение множеств a и b
print(c) # {'d', 1, (1, 'hello'), 'e', 'a', 'b', 'test', -2.5}

d=a&b # пересечение - обьединение пересекающийся элементов из указаных множеств
print(d) # {'a', 'b'}

# если пересекающийся множеств нет, то отобразится пустое множество - set()

a1 = {1,2,3,4,5}
b1 = {4,5,6,7,8}
c1 = a1-b1 # пересикающиейся элементы для a1,b1 убираем и в c1 ложим только уникальные (оставщиеся) элементы.
print(c1) # {1, 2, 3}

c2 = b1-a1
print(c2) # {8, 6, 7}

mn1={10,11,'test',45}
mn2={34,43,12,'aaa'}
mn3=mn1-mn2
print(mn3) # ничего не удалится, т.к. пересекающихся элементов нет

# МЕТОДЫ объединения, пересечения, разности и другие операции, работают так же и для вложенных структур хранения во множествах, например:

a1 = {1,2,3,4,5,(1,2,(10,11)),(5,6)}
b1 = {4,5,6,7,8,(1,2,(10,12)),(5,6)}
c1 = a1&b1
print(c1) # {(5, 6), 4, 5}

a10 = {'a','b','c','c','a','a'}
print(len(a10)) # считается количество только уникальных элементов. Уникальные только a, b ,c. Количество элементов равно 3
a10.discard('c')
print(a10)
print(len(a10)) # 2

#------------------------

#при копировании данных в новую переменную - данные копируются по ссылке.

test1 = {10,11,12}
test2 = test1

test1.add('e')
print(test1) # {'e', 10, 11, 12}
print(test2) # {'e', 10, 11, 12}

# для копирования по значению есть метод .copy в множествах.
# test2 = test1.copy()

#------------ операции с множествами

# set.isdisjoint(other) - истина, если set и other не имеют общих элементов

test1 = {10,11,12}
test2 = {11,13,14}
test3 = {10,11,12}
test4 = {1,2,3}

#print(test1.isdisjoint(test2)) # False, т.к. в множествах test1 и test2 есть общий элемент 11.

#------
# set == other - все элементы set принадлежат other, все элементы other принадлежат set.

# if test1 == test2:
#     print(True)
# else:
#     print(False)

#------
# set.issubset(other) или set <= other - все элементы set принадлежат other.

print(test1.issubset(test2)) # False
print(test1.issubset(test3)) # True

#------
#set.issuperset(other) или set >= other - аналогично.

print(test1.issubset(test2)) # False
print(test1.issubset(test3)) # True

#------
#про данные методы описано выше

#set.union(other, ...) или set | other | ... - объединение нескольких множеств.
#set.intersection(other, ...) или set & other & ... - пересечение.
#set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.

# set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих. Например:

#test1 = {10,11,12}
#test2 = {11,13,14}

print(test1^test2) #{10, 12, 13, 14}. Элемент 10 встречается только в множестве test1, элементы 12,13,14 встречаются только в множестве test2.
# В выводе отобразятся элементы, которые встречаются в одном множестве, но не встречающиеся в обоих.
